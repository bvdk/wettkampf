# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AgeClass {
  id: ID!
  name: String!
}

input AgeClassInput {
  name: String!
}

type Athlete {
  id: ID!
  eventId: ID!
  event: Event!
  athleteGroupId: ID
  athleteGroup: AthleteGroup
  slot: Slot
  importId: String
  firstName: String!
  lastName: String!
  name: String!
  gender: Gender!
  birthday: DateTime
  club: String
  norm: Boolean
  lateRegistration: Boolean
  price: String
  age: Int
  ageClassId: ID
  ageClass: AgeClass

  """Body weight in kg"""
  bodyWeight: Float
  weightClassId: ID
  weightClass: WeightClass

  """Attempt count"""
  attemptCount: Int!

  """Calc wilks"""
  wilks: Float

  """Calc dots"""
  dots: Float
  los: Int
  points: Float
  total: Float
  place: Int
  location: String
  attempts(discipline: Discipline): [Attempt!]!
  nextAttempts(discipline: Discipline): [Attempt!]
  bestAttempts(discipline: Discipline): [Attempt!]
  valid: Boolean
  nextAttemptsSortKeys: JSON
  resultClass: ResultClass
  raw: Boolean
}

type AthleteGroup {
  id: ID!
  eventId: ID!
  slotId: ID
  slot: Slot
  name: String!
  gender: Gender
  ageClassId: ID
  ageClass: AgeClass
  weightClassId: ID
  weightClass: WeightClass
  athletes(sort: [SortInput!]): [Athlete!]!
  athleteCount: Int!
  shallow: Boolean!
  active: Boolean!
  raw: Boolean
  sortId: Int
}

enum AthleteGroupCreationKey {
  GENDER
  AGE_CLASS
  WEIGHT_CLASS
  RAW
}

type AthleteGroupCreationResult {
  keys: [AthleteGroupCreationKey!]
  athletes: [Athlete!]!
  athleteGroups: [AthleteGroup!]!
}

input AthleteGroupInput {
  name: String
  gender: Gender
  ageClassId: ID
  weightClassId: ID
  raw: Boolean
  sortId: Int
}

input AthleteInput {
  importId: String
  athleteGroupId: ID
  firstName: String
  lastName: String
  gender: Gender
  birthday: DateTime
  club: String
  norm: Boolean
  lateRegistration: Boolean
  price: String
  ageClassId: ID

  """Body weight in kg"""
  bodyWeight: Float
  weightClassId: String
  los: Int
  raw: Boolean
}

input AthleteUpdateInput {
  importId: String
  athleteGroupId: ID
  firstName: String
  lastName: String
  gender: Gender
  birthday: DateTime
  club: String
  norm: Boolean
  lateRegistration: Boolean
  price: String
  ageClassId: ID

  """Body weight in kg"""
  bodyWeight: Float
  weightClassId: String
  los: Int
  raw: Boolean
}

type Attempt {
  id: ID!
  weight: Float
  valid: Boolean!
  done: Boolean!
  resign: Boolean!
  date: DateTime!
  discipline: Discipline!
  index: Int!
  raw: Boolean
}

input AttemptInput {
  weight: Float
  valid: Boolean
  done: Boolean
  resign: Boolean
  date: DateTime
  raw: Boolean
}

input AttemptUpdateInput {
  weight: Float
  valid: Boolean
  done: Boolean
  resign: Boolean
  date: DateTime
  raw: Boolean
}

enum ContestType {
  SINGLE
  TEAM
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

enum Discipline {
  BENCHPRESS
  SQUAT
  DEADLIFT
  POWERLIFTING
}

type Event {
  id: ID!
  name: String!
  discipline: Discipline
  availableDisciplines: [Discipline!]
  contestType: ContestType
  teamGender: Gender
  teamSize: Int
  groupOrder: [String!]
  currentDiscipline: Discipline
  slots: [Slot!]!
  athleteGroups: [AthleteGroup!]!

  """Athletes without valid group"""
  unsortedAthletes(filters: [FilterInput!]): [Athlete!]!
  athletes(filterBodyWeight: Boolean, sort: [SortInput!], filters: [FilterInput!]): [Athlete!]!
  results(sort: [SortInput!], filters: [FilterInput!]): [Athlete!]!
  officials: [Official!]!
  resultClasses: [ResultClass!]!
}

input EventInput {
  name: String
  discipline: Discipline
  contestType: ContestType
  teamGender: Gender
  teamSize: Int
  currentDiscipline: Discipline
}

input FilterInput {
  value: [String!]
  index: String!
}

enum Gender {
  MALE
  FEMALE
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type Mutation {
  createAgeClass(data: AgeClassInput!): AgeClass!
  updateAgeClass(data: AgeClassInput!, id: ID!): AgeClass!
  deleteAgeClass(id: ID!): AgeClass!
  createWeightClass(data: WeightClassInput!): WeightClass!
  updateWeightClass(data: WeightClassInput!, id: ID!): WeightClass!
  deleteWeightClass(id: ID!): WeightClass!
  createAthleteGroup(eventId: ID!, slotId: ID, data: AthleteGroupInput!): AthleteGroup!
  updateAthleteGroup(data: AthleteGroupInput!, id: ID!): AthleteGroup!
  updateAthleteGroupSort(slotId: ID!, oldIndex: Int!, newIndex: Int!): [AthleteGroup!]!
  setAthleteGroupSlot(athleteGroupId: ID!, slotId: ID!): AthleteGroup!
  addAthletesToAthleteGroup(athleteGroupId: ID!, athleteIds: [ID!]!): AthleteGroup!
  removeAthletesFromAthleteGroup(athleteGroupId: ID!, athleteIds: [ID!]!): AthleteGroup!
  deleteAthleteGroup(id: ID!): AthleteGroup!
  autoCreateAthleteGroups(
    """Wenn nicht gewählt werden alle Athleten ohne Startgruppe verwendet."""
    athleteIds: [ID!]
    eventId: ID!
    keys: [AthleteGroupCreationKey!]!

    """
    Maximale Startgruppengröße, wenn 0 werden alle passenden Athleten in eine Gruppe gespeichert.
    """
    maxGroupSize: Int

    """Wenn true werden bestehende Startgruppen mit einbezogen"""
    useExisting: Boolean

    """Gruppen auf bestehende Bühnen verteilen"""
    distributeSlots: Boolean
  ): AthleteGroupCreationResult!
  createSlot(eventId: ID!, data: SlotInput!): Slot!
  updateSlot(data: SlotInput!, id: ID!): Slot!
  deleteSlot(id: ID!): Slot!
  createEvent(data: EventInput!): Event!
  updateEvent(data: EventInput!, id: ID!): Event!
  deleteEvent(id: ID!): Event!
  createAthlete(eventId: ID!, data: AthleteInput!): Athlete!
  updateAthlete(data: AthleteUpdateInput!, id: ID!): Athlete!
  deleteAthlete(id: ID!): Athlete!
  createAttempt(athleteId: ID!, data: AttemptInput!, discipline: Discipline!): Attempt!
  updateAttempt(skipAutoCalc: Boolean, data: AttemptUpdateInput!, id: ID!): Attempt!
  autoCalcAthletePoints(id: ID!): Boolean!
  autoCalcEventPoints(id: ID!): Boolean!
  deleteAttempt(id: ID!): Attempt!
  removeAllAttempts(id: ID!): Boolean!
  simulateAttempts(id: ID!): Boolean!
  createOfficial(eventId: ID!, data: OfficialInput!): Official!
  updateOfficial(data: OfficialInput!, id: ID!): Official!
  deleteOfficial(id: ID!): Official!
  createOfficialSlot(slotId: ID!, officialId: ID!, input: OfficialSlotInput): OfficialSlot!
  updateOfficialSlot(input: OfficialSlotInput!, id: ID!): OfficialSlot!
  deleteOfficialSlot(id: ID!): OfficialSlot!
  setPublicConfig(data: PublicConfigInput!): PublicConfig!
}

type Official {
  id: ID!
  importId: String
  firstName: String!
  lastName: String!
  name: String!
  club: String
  position: String
  location: String
  license: String
}

input OfficialInput {
  firstName: String
  lastName: String
  club: String
  position: String
  location: String
  license: String
}

type OfficialSlot {
  id: ID!
  officialId: ID!
  official: Official!
  slotId: ID!
  slot: Slot!
  position: String!
}

input OfficialSlotInput {
  position: String!
}

type PublicConfig {
  event: Event!
  discipline: String!
  slot: Slot!
  nextAthletes: [Athlete!]!
  athleteGroups: [AthleteGroup!]!
}

input PublicConfigInput {
  eventId: String!
  discipline: String!
  slotId: String!
  athleteGroupIds: [String!]!
}

type Query {
  """All age classes"""
  ageClasses: [AgeClass!]!
  ageClass(id: ID!): AgeClass!

  """All weight classes"""
  weightClasses: [WeightClass!]!
  weightClass(id: ID!): WeightClass!
  athleteGroup(id: ID!): AthleteGroup!
  athleteGroups(sort: [SortInput!], filters: [FilterInput!]): [AthleteGroup!]!
  autoCreateAthleteGroupsPreview(
    """Wenn nicht gewählt werden alle Athleten ohne Startgruppe verwendet."""
    athleteIds: [ID!]
    eventId: ID!
    keys: [AthleteGroupCreationKey!]!

    """
    Maximale Startgruppengröße, wenn 0 werden alle passenden Athleten in eine Gruppe gespeichert.
    """
    maxGroupSize: Int

    """Wenn true werden bestehende Startgruppen mit einbezogen"""
    useExisting: Boolean

    """Gruppen auf bestehende Bühnen verteilen"""
    distributeSlots: Boolean
  ): AthleteGroupCreationResult!

  """Get a slot"""
  slot(id: ID!): Slot

  """Get all the events"""
  events: [Event!]!

  """Get a event"""
  event(id: ID!): Event!
  athletes: [Athlete!]!
  athlete(id: ID!): Athlete!
  findAthlete(eventId: ID, importId: ID): Athlete!
  attempt(id: ID!): Attempt!

  """Get a Official"""
  official(id: ID!): Official
  findOfficial(eventId: ID, importId: ID): Official!

  """Get a OfficialSlot"""
  officialSlot(id: ID!): OfficialSlot
  getPublicConfig: PublicConfig!

  """System info"""
  system: System!
}

type ResultClass {
  id: ID!
  name: String
  ageClassId: String
  ageClass: AgeClass
  weightClassId: String
  weightClass: WeightClass
  gender: Gender
  raw: Boolean
  athletes: [Athlete!]!
}

type Slot {
  id: ID!
  name: String!
  event: Event!
  eventId: String!
  activeAthleteGroupId: ID
  activeAthleteGroup: AthleteGroup
  activeDiscipline: Discipline
  index: Int!
  athletes: [Athlete!]!
  nextAthletes(filters: [FilterInput!]): [Athlete!]!
  athleteCount: Int!
  athleteGroups: [AthleteGroup!]!
  officialSlots: [OfficialSlot!]!
}

type SlotGroupChangedNotification {
  date: DateTime!
  athleteGroupIds: [String!]!
}

type SlotGroupChangedPayload {
  athleteGroupIds: [String!]!
}

input SlotInput {
  name: String
  activeAthleteGroupId: ID
  activeDiscipline: Discipline
}

enum SortDirection {
  ASC
  DESC
}

input SortInput {
  name: String
  direction: SortDirection
}

type Subscription {
  updateNextAthletesNotification: UpdateNotification!
  slotGroupChangedNotification: SlotGroupChangedNotification!
  subscribePublicConfig: PublicConfig!
}

type System {
  id: ID!
  version: String!
  name: String!
}

type UpdateNotification {
  date: DateTime!
  slotId: String!
}

type UpdateNotificationPayload {
  slotId: String!
}

type WeightClass {
  id: ID!
  name: String!
  min: Int!
  max: Int!
  gender: Gender
}

input WeightClassInput {
  name: String
  min: Int!
  max: Int!
  gender: Gender
}
